\section{System automation}
We have two tools at our disposal, one for correctly labeling a malware and the other for extracting its features. The objective now is to combine these two processes and build a program that will automate the analysis of all retrieved executables. Since these \textit{(features, label)} pairs will be added incrementally and used by the machine learning algorithms, we need to store such information and be able to retrieve these samples in an optimised fashion. To achieve this, we created a database which will be explained in detail in the next section.

The software responsible of all the analysis is a Python script soberly called \textit{detector.py}. It supports different options:

\begin{lstlisting}
$ ./detector.py -h
usage: detector.py [-h] [--date DATE] [--verbose] [--auto]
                   [--features] [--save] path

Packer detector

positional arguments:
  path           Path to the malware

optional arguments:
  -h, --help     show this help message and exit
  --date DATE    Date with the following structure YYYYMMDD
  --verbose, -v  Verbose
  --auto         Auto scan
  --features     Extract feature values
  --save         Save to db
\end{lstlisting}

We distinguish two ways to use the software. The first one allows to analyse several malware at once by providing the path to a folder. This folder needs to follow the hierarchy shown below, i.e. the malware need to be ordered in folders having the appropriate date as their names. By doing so, each piece of malware will be scanned and pushed into the database with its corresponding date.

\begin{lstlisting}
$ tree
myfolder/
|-- 20200101/    % 1st of January
|   |-- malware1
|   |-- malware2
|   |-- malware3
|-- 20200102/    % 2nd of January
|   |-- malware1
|   |-- malware2
|   |-- malware3
\end{lstlisting}
Otherwise, the second use allows to scan only one specific malware. You then have to call the script with the path to the malware and manually add its corresponding date.

\begin{lstlisting}
$ ./detector.py malware1 --date 20200101
\end{lstlisting}

In addition to simply ask for the nature of a binary, you can also ask  the software to perform the feature extraction by specifying the \texttt{features} argument. The \texttt{auto} option was implemented because we noticed that if the same malware is given multiple times, it will be re-scanned every time, which is unnecessarily time-consuming. With this option set, the tool will first look which information is missing for the given malware and will only perform the analysis for the missing data. This can for example happen if the feature extraction process was interrupted and only half of the features were computed.

\subsection{Accessing the Shadow server}

We would like to automate the process of malware retrieval from the Shadow server such that we can automatically scan for malware as soon as they are added by Cisco. In 10 months, we received the equivalent of 250GB worth of binary data but the server on which we are running the "super" detector is limited in space. Our system would then need to extract only the data it intends to work with and delete the original files afterwards. To meet this need, we developed the \textit{smart.py} script that works as follow:

\begin{enumerate}
    \item It looks at the archives that are available on the Shadow server.
    \item Thanks to SCP, it retrieves the oldest one that has not yet been analysed.
    \item It decompresses it and puts the malware in the appropriate folder. Each folder is named with the date in the format \textbf{YYYYMMDD}.
    \item It then runs the detector on this folder with the \texttt{auto} option.
    \item Once the malware is scanned, it will have to remove it to save memory space.
\end{enumerate}
This script can then be run within a \texttt{crontab} to scan for new available malware on a daily basis.

\subsection{Docker encapsulation}

Since our global detector uses external software, they all have to be installed beforehand. Moreover, they all have to run on the same OS, precisely Linux, for the reasons mentioned earlier. To alleviate the burden of such installations, we gathered everything - the fundamental detectors and our automated tool - in a docker container with an Ubuntu image. This means that with Docker installed, the container can be launched no matter the running operating system. Once the image of the container is created, the container can be started by mounting the directory with the malware as follow:
\begin{lstlisting}
$ docker run -it -v /home/jroussieau/Documents/malware:/malware detector:latest /bin/bash
\end{lstlisting}
In this example, the \textit{malware} directory located in our Documents folder was mounted. The \texttt{/bin/bash} option was also specified so that the detector script can be started via an interactive shell.